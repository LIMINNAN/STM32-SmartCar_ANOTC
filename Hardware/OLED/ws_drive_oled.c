#include "ws_drive_oled.h"
#include "ws_oled_font.h"
#include "oled_buffer.h"
#include <stdarg.h>		  //  标准头文件
#include <stdio.h>
#include "string.h"




extern uint8_t ScreenBuffer[SCREEN_PAGE_NUM][SCREEN_COLUMN];
extern uint8_t TempBuffer[SCREEN_PAGE_NUM][SCREEN_COLUMN];
extern  _Bool _SelectedBuffer;
extern uint8_t oledDidBufPageCount;


extern I2C_HandleTypeDef hi2c1;
#define OLED_hi2c hi2c1




// 连续写数据进入OLED 
char WS_OLED_Write_Buffer(char adds , uint8_t *data ,int len)   
{
	  return HAL_I2C_Mem_Write(&OLED_hi2c,0x78,adds,I2C_MEMADD_SIZE_8BIT ,(uint8_t *)data,len,5);    
}
// 连续写数据进入OLED 
char WS_OLED_Write_Buffer_DMA(char adds , uint8_t *data ,int len)   
{
	  return HAL_I2C_Mem_Write_DMA(&OLED_hi2c,0x78,adds,I2C_MEMADD_SIZE_8BIT ,(uint8_t *)data,len);    
}

 
//   写入OLED 命令
void WS_OLED_Write_Cmd(unsigned char cmd)
{
	 HAL_I2C_Mem_Write(&OLED_hi2c,0x78,0x00,I2C_MEMADD_SIZE_8BIT ,&cmd,1,1);
}

//   写入OLED 数据
void WS_OLED_Write_Dat(unsigned char dat)
{
	 HAL_I2C_Mem_Write(&OLED_hi2c,0x78,0x40,I2C_MEMADD_SIZE_8BIT ,&dat,1,1);
	  
}

//  设置缓存
//  注意：显存模式下， 数组越界的风险
//  x: 0 ~ 127 , y :0~7
void  WS_OLED_Set_Buffer(int   x, int   y , uint8_t *dat , uint16_t size) 
{
	  if(x<0||x>=128||y<0||y>=8)  return  ;
#if WS_OLED_EN_DIS_BUFFER == 0	  //  直写寄存器模式
		WS_OLED_Write_Cmd(0xb0+y);
		WS_OLED_Write_Cmd(((x&0xf0)>>4)|0x10);
		WS_OLED_Write_Cmd( (x&0x0f)); 
		WS_OLED_Write_Buffer(0x40,dat , size);
#else                            //   显存模式
	  if(y*128 + x + size > sizeof(ScreenBuffer))  return ; //  防止越界 
	  if( GetSelectedBuffer()==SCREEN_BUFFER)
	{
			memcpy(ScreenBuffer[y]+x,dat,size) ;
	}
	else
	{
			memcpy(TempBuffer[y]+x,dat,size) ;
	}
    	
#endif	
}   	

//  开启OLED显示    
void WS_OLED_Open_Dis(void)
{
	WS_OLED_Write_Cmd(0X8D);  //SET DCDC命令
	WS_OLED_Write_Cmd(0X14);  //DCDC ON
	WS_OLED_Write_Cmd(0XAF);  //DISPLAY ON
}
// 关闭OLED显示     
void WS_OLED_Close_Dis(void)
{
	WS_OLED_Write_Cmd(0X8D);  //SET DCDC命令
	WS_OLED_Write_Cmd(0X10);  //DCDC OFF
	WS_OLED_Write_Cmd(0XAE);  //DISPLAY OFF
}


// 全屏熄灭	  
void WS_OLED_Clear(void)  
{  
	int i,n;		    
	for(i=0;i<8;i++)  
	{  
		WS_OLED_Write_Cmd (0xb0+i);    //设置页地址（0~7）
		WS_OLED_Write_Cmd (0x00);      //设置显示位置―列低地址
		WS_OLED_Write_Cmd (0x10);      //设置显示位置―列高地址   
		for(n=0;n<128;n++) 
     {		
		   WS_OLED_Write_Dat(0) ;
			 
#if  WS_OLED_EN_DIS_BUFFER		 == 1	 
			 ScreenBuffer[i][n] = 0;
#endif
		 } 
	} 
}

//    点亮全屏
void WS_OLED_Full(void)  
{  
	unsigned char  i,n;		    
	for(i=0;i<8;i++)  
	{  
		WS_OLED_Write_Cmd (0xb0+i);    //设置页地址（0~7）
		WS_OLED_Write_Cmd (0x00);      //设置显示位置―列低地址
		WS_OLED_Write_Cmd (0x10);      //设置显示位置―列高地址   
		for(n=0;n<128;n++)
		{ 
			  WS_OLED_Write_Dat(0xff)   ;
#if  WS_OLED_EN_DIS_BUFFER			 
			 ScreenBuffer[i][n] = 0xff;//全部写1清零，ScreenBuffer
#endif
		}			
	}
}

//  显示字符串
//  disMode :  0->5*7  ; 1->8*16 ; 2->12*24 ; 3->16*32
void WS_OLED_Dis_String(int  x,int   y,   char disMode, char  *string)
{
	int index=0;
	uint8_t   c= 0         ;
  uint8_t  	buffer[128]  ; 
	while (string[index]>0)
	{		
		c = string[index] ;
		switch(disMode)
		{
			case 10:
			case  0:
				        if(c < 0x80)  //  ASCII 字符 
								{
									 memcpy((char *)buffer,ASCII6X8Code[c- ' '],6);
									 if(disMode == 10)  {
									   int i;
										 for(i=0;i<6;i++) buffer[i] = ~buffer[i];
									 }
									 WS_OLED_Set_Buffer(x,y,buffer,6);
									 x += 6;	
									 if(x>128-6){x=0;y=y+1;}	// 自动换行
							  } 
				        break;
								
			case 11:					
			case 1 :
                if(c < 0x80)  //  ASCII 字符 
								{
										c -= ' ' ;
									  memcpy((char *)buffer,ASCII8X16Code[c],16);
									  if(disMode == 11)  {
									   int i;
										 for(i=0;i<16;i++) buffer[i] = ~buffer[i];
									 }
										WS_OLED_Set_Buffer(x,y,buffer,8);						
										WS_OLED_Set_Buffer(x,y+1,buffer+8,8);
										
			          }
			          x += 8;     //  自动换行
			          if(x>120)
								{
									 x=0  ;
									 y=y+2;
								} 
		            break;
#if ASCII12X24Code_EN != 0 								
      case 12:								
			case 2:
                if(c < 0x80)  //  ASCII 字符 
								{
										c -= ' ' ;
									  memcpy(buffer,ASCII12X24Code[c],36);
									  if(disMode == 12)  {
									   int i;
										 for(i=0;i<36;i++) buffer[i] = ~buffer[i];
									  }
										WS_OLED_Set_Buffer(x,y,buffer,12);										
										WS_OLED_Set_Buffer(x,y+1,buffer+12,12);
                    WS_OLED_Set_Buffer(x,y+2,buffer+24,12);
														
			          }
			          x += 12;     //  自动换行
			          if(x>116)
								{
									 x=0  ;
									 y=y+3;
								} 
		            break;  
#endif
								
#if ASCII12X24Code_EN != 0
			case 13:					   
			case 3:
                if(c < 0x80)  //  ASCII 字符 
								{
										c -= ' ' ;
									  memcpy(buffer,ASCII16X32Code[c],64);
									  if(disMode == 13)  {
									   int i;
										 for(i=0;i<64;i++) buffer[i] = ~buffer[i];
									   }
										WS_OLED_Set_Buffer(x,y,buffer,16);										
										WS_OLED_Set_Buffer(x,y+1,buffer+16,16);
                    WS_OLED_Set_Buffer(x,y+2,buffer+32,16);
										WS_OLED_Set_Buffer(x,y+3,buffer+48,16);
			          }
			          x += 16;     //  自动换行
			          if(x>112)
								{
									 x=0  ;
									 y=y+4;
								} 
		            break; 
#endif								
      default:  
			        break;  
		}
		
		if(y > 7)  break;	  //  显示超行，退出
		index++;
	}
}


//  显示点阵信息
//  disMode :    1->16*16 ; 2->24*24 ; 3->32*32
void WS_OLED_Dis_Date(int  x,int   y,   char disMode, char  *date , uint16_t  len)
{
  uint8_t  	buffer[128]  ; 
	while (len -- )
	{		
		switch(disMode)
		{								
			case 11:					
			case 1 : 
								memcpy((char *)buffer,date,32);
								if(disMode == 11)  
								{
									int i;
									for(i=0;i<32;i++) buffer[i] = ~buffer[i];
								}
								WS_OLED_Set_Buffer(x,y,buffer,16);						
								WS_OLED_Set_Buffer(x,y+1,buffer+16,16);
			          
			          x += 16; 
                date  += 32;								
			          if(x>128 - 16)   //  自动换行
								{
									 x=0  ;
									 y=y+2;
								} 
		            break;							
      case 12:								
			case 2:
                memcpy((char *)buffer,date,72);
								if(disMode == 12)  
								{
									int i;
									for(i=0;i<72;i++) buffer[i] = ~buffer[i];
								}
								WS_OLED_Set_Buffer(x,y,buffer,24);						
								WS_OLED_Set_Buffer(x,y+1,buffer+24,24);
								WS_OLED_Set_Buffer(x,y+2,buffer+48,24);
			          
			          x += 24; 
                date  += 72;								
			          if(x > 128 - 24)   //  自动换行
								{
									 x=0  ;
									 y=y+3;
								} 
		            break;  

								
			case 13:					   
			case 3:
                memcpy((char *)buffer,date,128);
								if(disMode == 13)  
								{
									int i;
									for(i=0;i<128;i++) buffer[i] = ~buffer[i];
								}
								WS_OLED_Set_Buffer(x,y,buffer,32);						
								WS_OLED_Set_Buffer(x,y+1,buffer+32,32);
								WS_OLED_Set_Buffer(x,y+2,buffer+64,32);
								WS_OLED_Set_Buffer(x,y+3,buffer+96,32);
			          
			          x += 32; 
                 date  += 128;    								
			          if(x > 128 - 32)   //  自动换行
								{
									 x=0  ;
									 y=y+4;
								} 
		            break; 							
      default:  
			          break;  
		}
		
		if(y > 7)  break;	  //  显示超行，退出
	}
}



//  OLED 格式化输出
void WS_OLED_Printf(int  x,int  y, char disMode , char *p,... )
{
	  static  char buf[256];
    va_list ap;
		va_start(ap,p);
		vsprintf(buf,p,ap);
		va_end(ap);
	  WS_OLED_Dis_String(x,y,disMode,buf);
}





//初始化SSD1306					    
void WS_OLED_Init(void)
{ 	  	 
		WS_OLED_Write_Cmd(0xAE);//--display off
    WS_OLED_Write_Cmd(0x00);//---set low column address
    WS_OLED_Write_Cmd(0x10);//---set high column address
    WS_OLED_Write_Cmd(0x40);//--set start line address  
    WS_OLED_Write_Cmd(0xB0);//--set page address
    WS_OLED_Write_Cmd(0x81); // contract control
    WS_OLED_Write_Cmd(0xFF);//--128   
    WS_OLED_Write_Cmd(0xA1);//set segment remap 
    WS_OLED_Write_Cmd(0xA6);//--normal / reverse
    WS_OLED_Write_Cmd(0xA8);//--set multiplex ratio(1 to 64)
    WS_OLED_Write_Cmd(0x3F);//--1/32 duty
    WS_OLED_Write_Cmd(0xC8);//Com scan direction
    WS_OLED_Write_Cmd(0xD3);//-set display offset
    WS_OLED_Write_Cmd(0x00);//
     
    WS_OLED_Write_Cmd(0xD5);//set osc division
    WS_OLED_Write_Cmd(0xf0);//
     
    WS_OLED_Write_Cmd(0xD8);//set area color mode off
    WS_OLED_Write_Cmd(0x05);//
     
    WS_OLED_Write_Cmd(0xD9);//Set Pre-Charge Period
    WS_OLED_Write_Cmd(0xF1);//
     
    WS_OLED_Write_Cmd(0xDA);//set com pin configuartion
    WS_OLED_Write_Cmd(0x12);//
     
    WS_OLED_Write_Cmd(0xDB);//set Vcomh
    WS_OLED_Write_Cmd(0x30);//
     
    WS_OLED_Write_Cmd(0x8D);//set charge pump enable
    WS_OLED_Write_Cmd(0x14);//
     
    WS_OLED_Write_Cmd(0xAF);//--turn on oled panel
		
		SetScreenBuffer();
		ClearTempBuffer();
		WS_OLED_Clear();    //  清屏
		
		UpdateScreenBuffer();
		SetTempBuffer();
	
} 


//  启动一次DMA传输，实训缓存更新
//  50~200MS更新一次
//为上层提供硬件操作接口OLED_FILL
void UpdateScreenBuffer(void)
{
#if WS_OLED_EN_DIS_BUFFER != 0	
    uint8_t  buf[3] ;
	oledDidBufPageCount = 0;
	
	buf[0] =  0xb0 + oledDidBufPageCount;
	buf[1] =  0x00;
	buf[2] =  0x10;
	WS_OLED_Write_Buffer(0x00,buf,3); //  发送命令，寄存器地址0x00 ;
	// 启动DMA传输
	WS_OLED_Write_Buffer_DMA(0x40,(uint8_t *)ScreenBuffer[0],128);
#endif
}

//为上层提供硬件操作接口OLED_FILL
void UpdateTempBuffer(void)
{
	#if WS_OLED_EN_DIS_BUFFER != 0	
  uint8_t  buf[3] ;
	oledDidBufPageCount = 0;
	
  buf[0] =  0xb0 + oledDidBufPageCount;
  buf[1] =  0x00;
  buf[2] =	0x10;
	WS_OLED_Write_Buffer(0x00,buf,3); //  发送命令，寄存器地址0x00 ;
	// 启动DMA传输
	WS_OLED_Write_Buffer_DMA(0x40,(uint8_t *)TempBuffer[0],128);
#endif
}

//  oled 缓存定时更新任务
int WS_OLED_Task_Buffer_Update(void *date)
{	
	
    UpdateScreen() ;  
	
	  return 50;
}

#if WS_OLED_EN_DIS_BUFFER != 0	
/**
  * @brief  Memory Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
	if( ++ oledDidBufPageCount < 8)  //  1 ~ 7
	{  

		uint8_t  buf[3] ;
		buf[0] =  0xb0 + oledDidBufPageCount;
		buf[1] =  0x00;
		buf[2] =	0x10;
		//  用阻塞发送缓存传输的坐标点
		//HAL_I2C_Mem_Write(&OLED_hi2c,0x78,0x00,I2C_MEMADD_SIZE_8BIT ,buf,3,1);
		WS_OLED_Write_Buffer(0x00,buf,3); //  发送命令，寄存器地址0x00 ;		
//	   WS_OLED_Write_Cmd (0xb0+oledDidBufPageCount);    //设置页地址（0~7）
//	   WS_OLED_Write_Cmd (0x00);                        //设置显示位置―列低地址
//	   WS_OLED_Write_Cmd (0x10);                        //设置显示位置―列高地址    
	   WS_OLED_Write_Buffer_DMA(0x40,(uint8_t *)ScreenBuffer[oledDidBufPageCount],128);    
	}
}



//const uint8_t  oledDisplayTestCode16X16[]=
//{
//0x00,0x00,0x00,0xFE,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0xFE,0x00,0x00,0x00,0x00,0x40,0x42,0x44,0x58,0x40,0x7F,0x40,0x40,0x40,0x7F,0x40,0x50,0x48,0x46,0x40,0x00,/*"显",0*/
//0x40,0x40,0x42,0x42,0x42,0x42,0x42,0xC2,0x42,0x42,0x42,0x42,0x42,0x40,0x40,0x00,0x20,0x10,0x08,0x06,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x02,0x04,0x08,0x30,0x00,/*"示",1*/
//0x10,0x60,0x02,0x8C,0x00,0xFE,0x02,0xF2,0x02,0xFE,0x00,0xF8,0x00,0xFF,0x00,0x00,0x04,0x04,0x7E,0x01,0x80,0x47,0x30,0x0F,0x10,0x27,0x00,0x47,0x80,0x7F,0x00,0x00,/*"测",2*/
//0x40,0x40,0x42,0xCC,0x00,0x90,0x90,0x90,0x90,0x90,0xFF,0x10,0x11,0x16,0x10,0x00,0x00,0x00,0x00,0x3F,0x10,0x28,0x60,0x3F,0x10,0x10,0x01,0x0E,0x30,0x40,0xF0,0x00/*"试",3*/
//};
//const uint8_t  oledDisplayTestCode24X24[]=
//{
//0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0xFC,0xFC,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xC0,0x80,0x8F,0x0F,0x0C,0xFC,0xF4,0x14,0x04,0x04,0xF4,0xF4,0x04,0x0F,0x8F,0xE0,0x60,0x20,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x13,0x17,0x17,0x10,0x1F,0x1F,0x10,0x10,0x10,0x1F,0x1F,0x16,0x13,0x11,0x10,0x18,0x18,0x10,0x00,/*"显",0*/
//0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0C,0x0C,0x08,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x82,0xE2,0xF2,0x72,0x02,0x02,0xFE,0xFE,0xFE,0x02,0x12,0x32,0x62,0xC2,0x82,0x02,0x03,0x03,0x00,0x00,0x10,0x18,0x0C,0x07,0x03,0x01,0x10,0x10,0x30,0x70,0x7F,0x3F,0x1F,0x00,0x00,0x00,0x00,0x01,0x03,0x0F,0x0E,0x04,0x00,/*"示",1*/
//0x00,0x80,0x80,0x04,0x1C,0x18,0x10,0xF8,0xF8,0xF8,0xC8,0xC8,0xC8,0xF8,0xF8,0xF8,0x00,0xC0,0xC0,0x40,0xFC,0xFC,0x00,0x00,0x00,0x00,0x01,0x07,0xC7,0xF8,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x01,0x3F,0x3F,0x7F,0x60,0x23,0x3B,0x1F,0x0F,0x07,0x04,0x1D,0x39,0x30,0x00,0x01,0x21,0x60,0x7F,0x7F,0x00,0x00,/*"测",2*/
//0x00,0x00,0x00,0x08,0x38,0xF0,0xE0,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x8C,0xFC,0xF8,0x88,0x98,0xB8,0xF0,0xC0,0x80,0x00,0x04,0x04,0x04,0x04,0xFC,0xFC,0x04,0x08,0x08,0x08,0x08,0xF8,0xF8,0x0C,0x0C,0x3F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x3F,0x3F,0x1C,0x06,0x1B,0x19,0x08,0x0F,0x07,0x04,0x06,0x02,0x01,0x07,0x1F,0x3C,0x30,0x7E,0x6E,/*"试",3*/
//};

//const uint8_t  oledDisplayTestCode32X32[]=
//{

//0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xF8,0xF0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xF8,0xF8,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x38,0x70,0xF1,0xE1,0xC0,0x00,0x00,0xFE,0xFE,0xFE,0x00,0x00,0x00,0xFE,0xFE,0xFE,0x00,0x80,0xC0,0xE0,0x78,0x3C,0x1C,0x08,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x11,0x13,0x13,0x10,0x10,0x1F,0x1F,0x1F,0x10,0x10,0x10,0x1F,0x1F,0x1F,0x16,0x13,0x11,0x10,0x10,0x18,0x18,0x18,0x10,0x00,0x00,/*"显",0*/
//0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x38,0x38,0x30,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x30,0x30,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0x7C,0x3E,0x1E,0x06,0x04,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x02,0x06,0x0C,0x18,0x78,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x08,0x0C,0x07,0x03,0x01,0x00,0x00,0x08,0x08,0x18,0x10,0x30,0x70,0x7F,0x3F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x07,0x03,0x00,0x00,/*"示",1*/
//0x00,0x00,0x00,0x00,0x0C,0x1C,0x78,0x70,0x60,0x00,0xF8,0xF8,0xF0,0x10,0x10,0x10,0x10,0x10,0xF0,0xF0,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0xFC,0xFC,0xF8,0x00,0x00,0x00,0x00,0x04,0x1C,0x7C,0x78,0x30,0xC0,0xF8,0x38,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFE,0x02,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x01,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x20,0x20,0x60,0xE0,0xF0,0xFC,0x3F,0x03,0x00,0x7F,0x7F,0x3F,0xE0,0xFF,0xFF,0x80,0x00,0x3F,0x3F,0x1F,0x00,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x1F,0x40,0x60,0x30,0x18,0x1C,0x0F,0x07,0x01,0x00,0x01,0x07,0x1E,0x3C,0x3C,0x00,0x00,0x10,0x10,0x30,0x70,0x7F,0x3F,0x0F,0x00,0x00,/*"测",2*/
//0x00,0x00,0x00,0x00,0x10,0x30,0xF0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0xF8,0x08,0x18,0x38,0xF0,0xF0,0x80,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0xC1,0xE1,0xE1,0x40,0x02,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0xC2,0xC2,0xFF,0xFF,0xFF,0x02,0x02,0x02,0x02,0x03,0x03,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x80,0xC0,0x40,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x80,0x80,0x8F,0x7F,0xFE,0xE0,0x80,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x3F,0x3F,0x1E,0x07,0x05,0x0C,0x0C,0x06,0x07,0x03,0x03,0x03,0x01,0x01,0x00,0x00,0x00,0x01,0x07,0x0F,0x1E,0x3C,0x7F,0x7F,0x00,/*"试",3*/
//};
#endif
































